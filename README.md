# 2D-Systolic-Array-Multiplier

This repository implements a synthesizable two dimensional systolic array that can be configured to multiply 2 square matrices of any dimension.

The `rtl` sub-directory contains the RTL written in System Verilog and the `tb` sub-directory contains the test bench written in C++ and simulated using Verilator.

## TL;DR

Requirements: `Verilator` and `GNU Make`.

To simulate the TB generating random NxN input matrices, driving the DUT ports and displaying the result matrix generated by the DUT:

1. Clone the repository:
```
git clone https://github.com/tms4517/2D-Systolic-Array-Multiplier.git
```
2. By default the RTL and TB are configured to a matrix size of 4x4.

To modify the default matrix size: `cd rtl`, open `topSystolicArray.sv` and modify the paramater `N`. And, `cd tb`, open `tb_topSystolicArray.sv` and modify the macro `N`. Note,  `N` > 2 and verilator crashes for large matrix dimensions (>100 on my PC).

3. Run the simulation:
```
cd tb && make all
```

## Introduction

### Systolic architectures

(describe and explain seminal paper: "Why Systolic Architectures?": https://www.cse.wustl.edu/~roger/560M.f17/01653825.pdf)

### Existing implementations

(describe Google's TPU. Blog: https://cloud.google.com/blog/products/ai-machine-learning/an-in-depth-look-at-googles-first-tensor-processing-unit-tpu. Paper: https://arxiv.org/pdf/1704.04760.pdf)

## Design

Interfacing to the top level module - `topSystolicArray.sv` has been kept simple.
Besides `i_clk` and `i_arst`, there are two input ports to drive the matrices A
and B - `i_a` and `i_b`. These ports are sampled, when the input port
`i_validInput` is asserted. The input matrices are then transformed and passed
to the systolic array for multiplication. When the matrix multiplication has
completed, output port `i_validInput` is asserted and the result matrix - `o_c`
can be sampled.

The waveform below shows the interface being exercised.
![Interface](images/interface.png)

The elements of the input matrices are 8 bit integers. This was chosen out of
simplicity and provides an appropriate level of accuracy for neural network
calculations, as described in Google's TPU blog post. Moreover, the elements of
the output matrix are set to 32 bits. This was chosen out of convenience for
verifying any NxN input matrix. Note: The element widths can be modified
with care.

The overall steps involved in performing the matrix multiplication using the
systolic array follows the steps outlined in this YouTube video:
https://www.youtube.com/watch?v=cmy7LBaWuZ8 and are described below.
To align to it and make it easier to follow the steps, a 4x4 matrix will be used
as example.

### Set-up the row and column matrices



### Pass the elements from the row and column matrices to the systolic array


## Verification

(Summary of verification)

## Further Work

(SIMD processor)
(unpacked data types to perform synthesis)

**STATUS**: RTL & TB complete. Documentation in progress.
